<div class="paragraph">
<p>A couple of days ago, I faced an issue with Monitoring the Progress of an HTTP Request. According to old developers' tradition, firstly, I asked Google for it. I anticipated getting a bunch of different answers and choosing an appropriate one. This time my instincts failed me. Even though I got a bunch of similar solutions, I didn&#8217;t find the appropriate example. It is worth clarifying that I&#8217;m working on a NestJS-based project. Let me explain why I decided to create my solution from scratch and why most of the existing solutions on the topic need to be revised in my case.</p>
</div>
<div class="paragraph">
<p>First, I want to share the <a href="https://dev.to/tqbit/how-to-monitor-the-progress-of-a-javascript-fetch-request-and-cancel-it-on-demand-107f" target="_blank" rel="noopener">article that describes a bunch of the results above as well as possible</a>. Let me provide essential thoughts on the article.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The article describes the request that provides content downloading. In this case, we are talking about the precious content size.<br></p>
</li>
<li>
<p>The <mark>Content-Length</mark> HTTP header is essential to the correct HTTP response.<br></p>
</li>
<li>
<p>After the server application sets <mark>Content-Length</mark>, chunked data writing process should be run.<br></p>
</li>
<li>
<p>First, the client application gets <mark>Content-Length</mark>.<br></p>
</li>
<li>
<p>After that, it gets every data chunk and calculates the progress as the following.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">progress = 100 * (chunkSize / contentLength)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The approach above is beneficial if we are talking about content downloading. Despite it doesn&#8217;t work in my case due to the following reasons.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>My task is about something other than content downloading. Moreover, we need to have a functionality that allows us to calculate the progress according to calculations, not only according to data transfer.<br></p>
</li>
<li>
<p>Despite the application not knowing the content size, it has a total number of iterations.<br></p>
</li>
<li>
<p>Chunk-based approach doesn&#8217;t work in this case. The final result preparation will take a long time, and the output data should be written to the response simultaneously. That&#8217;s why we need to inform the client before sending a response.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In other words, the requirements for the new approach are the following.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The response writing goes simultaneously without any data chunking.<br></p>
</li>
<li>
<p>The progress should be provided before that.<br></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>I don&#8217;t want to waste your time and give a couple of conceptual points of my approach regarding accounting the requirements above.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provide the progress via WebSockets because of persistent connection and high performance.</p>
</li>
<li>
<p>Connect WebSockets with a current session to pass all needed data from the HTTP request processing process.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All thoughts and code below will be strongly connected to these points. But before, let me share the <a href="https://github.com/buchslava/nest-request-progress" target="_blank" rel="noopener">final solution</a>.</p>
</div>
<div class="sect1">
<h2 id="_data_providing_example">Data Providing Example</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I provided a simplified version of the data processing because I want to focus on this task. We have 150 iterations in the example below. The result is an array of 150 random numbers, each calculates in 100 - 1000 milliseconds. I found this example as a minimally viable model of the objective process.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import { Injectable } from '@nestjs/common';

const getRandomArbitrary = (min: number, max: number): number =&gt;
  Math.random() * (max - min) + min;
const delay = (time: number) =&gt;
  new Promise((resolve) =&gt; setTimeout(resolve, time));

@Injectable()
export class AppService {

  getIterationCount(): number {
    return 150;
  }

  async getData(token: string): Promise&lt;string[]&gt; {
    return new Promise(async (resolve, reject) =&gt; {
      try {
        const result = [];

        for (let i = 0; i &lt; this.getIterationCount(); i++) {
          result.push(getRandomArbitrary(1, 9999));
          await delay(getRandomArbitrary(100, 1000));
        }

        resolve(result);
      } catch (e) {
        reject(e);
      }
    });
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_progress_manager">Progress Manager</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The future steps are regarding the <mark>ProgressManager</mark> implementation.</p>
</div>
<div class="paragraph">
<p>The <mark>ProgressManager</mark> should be a separate NestJS service able to do the following.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start the "Progress" session (Not the HTTP session) with the unique token taken from the client application.<br></p>
</li>
<li>
<p>Stop the "Progress" session<br></p>
</li>
<li>
<p>Increase the value of the progress.<br></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Please look at the following commented code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import { Injectable } from '@nestjs/common';
import { Server } from 'socket.io';

export interface ProgressSession {
  token: string;
  total: number;
  counter: number;
  timerId: any;
}

@Injectable()
export class ProgressManager {
  // The Socket Server injection will be described later
  public server: Server;
  // This map contains all Progress session data
  private storage: Map&lt;string, ProgressSession&gt; = new Map();

  // Start the session with the token and the total number of iterations
  startSession(token: string, total: number, delay = 2000) {
    // Get current session from the storage
    const currentSession = this.storage.get(token);
    // Do nothing if it's already exist
    if (currentSession) {
      return;
    }
    // Send the progress every "delay" milliseconds
    const timerId = setInterval(async () =&gt; {
      const currentSession: ProgressSession = this.storage.get(token);
      // Protect the functionality: if the current session is missing then do nothing
      if (!currentSession) {
        return;
      }
      // Calculate the progress
      let progress = Math.ceil(
        (currentSession.counter / currentSession.total) * 100
      );
      // Protect the progress value, it should be less or equal 100
      if (progress &gt; 100) {
        progress = 100;
      }
      // Send the progress. Pay attention that the event name should contain the "token"
      // Client will use this token also
      this.server.emit(`progress-${token}`, progress);
    }, delay);
    // Initial Progress Session settings. Token is a key.
    this.storage.set(token, {
      token,
      total,
      counter: 0,
      timerId,
    });
  }

  // This method increases the progress
  step(token: string, value = 1) {
    // Get the current session
    const currentSession: ProgressSession = this.storage.get(token);
    // Do nothing if it doesn't exist
    if (!currentSession) {
      return;
    }
    // Increase the counter
    const counter = currentSession.counter + value;
    // Update the storage
    this.storage.set(token, {
      ...currentSession,
      counter,
    });
  }

  // Stop the session by the token
  stopSession(token: string) {
    // Get the current session
    const currentSession: ProgressSession = this.storage.get(token);
    // Do nothing if it doesn't exist
    if (currentSession) {
      // Stop the current timer
      clearInterval(currentSession.timerId);
      // Remove information regarding the current session from the storage
      this.storage.delete(token);
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can find the code above <a href="https://github.com/buchslava/nest-request-progress/blob/main/packages/server/src/app/progress-manager.ts" target="_blank" rel="noopener">here</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_websockets_server">WebSockets Server</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another important is the integration of NestJS with WebSockets and connecting the Progress Manager with it. The following code is responsible for that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayInit,
} from '@nestjs/websockets';
import { Server } from 'socket.io';
import { ProgressManager } from './progress-manager';

@WebSocketGateway({ cors: true })
export class AppGateway implements OnGatewayInit {
  constructor(private progressManager: ProgressManager) {}

  @WebSocketServer() server: Server;

  afterInit() {
    // After the WebSockets Gateway has to init, then pass it to the ProgressManager
    this.progressManager.server = this.server;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/buchslava/nest-request-progress/blob/main/packages/server/src/app/app.gateway.ts" target="_blank" rel="noopener">The source &gt;&gt;</a><br>
And, of course, according to NestJS requirements, we need to tell the related module about that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import { Module } from '@nestjs/common';

import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AppGateway } from './app.gateway';
import { ProgressManager } from './progress-manager';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService, AppGateway, ProgressManager],
})
export class AppModule {}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/buchslava/nest-request-progress/blob/main/packages/server/src/app/app.module.ts" target="_blank" rel="noopener">The source &gt;&gt;</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_data_processing">Data Processing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s time to focus on the endpoint&#8217;s controller. It looks pretty simple.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import { Controller, Get, Query } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getData(@Query() query: { token: string }) {
    return this.appService.getData(query.token);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/buchslava/nest-request-progress/blob/main/packages/server/src/app/app.controller.ts" target="_blank" rel="noopener">The source &gt;&gt;</a></p>
</div>
<div class="paragraph">
<p>And the last thing about the server is regarding the Data Providing Example modification. The following example is close to the first example in this article. The main aim is to add "Progress functionality" here. Please, read the comment in the code. It&#8217;s important.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import { Injectable } from '@nestjs/common';
import { ProgressManager } from './progress-manager';

const getRandomArbitrary = (min: number, max: number): number =&gt;
  Math.random() * (max - min) + min;
const delay = (time: number) =&gt;
  new Promise((resolve) =&gt; setTimeout(resolve, time));

@Injectable()
export class AppService {
  // Use progressManager
  constructor(private readonly progressManager: ProgressManager) {}

  // 150 iterations should be processed
  getIterationCount(): number {
    return 150;
  }

  async getData(token: string): Promise&lt;string[]&gt; {
    return new Promise(async (resolve, reject) =&gt; {
      // We need to start the Progress Session before data preparation
      this.progressManager.startSession(token, this.getIterationCount());
      try {
        // Initialize the array of results
        const result = [];

        for (let i = 0; i &lt; this.getIterationCount(); i++) {
          // Calculate the result
          result.push(getRandomArbitrary(1, 9999));
          // Increase the Progress counter
          this.progressManager.step(token);
          // Random delay
          await delay(getRandomArbitrary(100, 1000));
        }

        // Return the result
        resolve(result);
      } catch (e) {
        reject(e);
      } finally {
        // We need to stop the ProgressManager in any case.
        // Otherwise, we have a redundant timeout.
        this.progressManager.stopSession(token);
      }
    });
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/buchslava/nest-request-progress/blob/main/packages/server/src/app/app.service.ts" target="_blank" rel="noopener">The source &gt;&gt;</a></p>
</div>
<div class="paragraph">
<p>The backend part of my example is ready. You can find the full backend solution <a href="https://github.com/buchslava/nest-request-progress/tree/main/packages/server" target="_blank" rel="noopener">here</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_client">The Client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The client part of my example is placed <a href="https://github.com/buchslava/nest-request-progress/tree/main/packages/client" target="_blank" rel="noopener">here</a>. Both parts are placed in one monorepo. Thanks <a href="https://nx.dev/" target="_blank" rel="noopener">Nx</a> for that. Lets look at it. Please, read the comments in the code below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import * as io from 'socket.io-client';
import { v4 } from 'uuid';
import axios from 'axios';

// Generate a unique ID (token)
const token = v4();

console.info(new Date().toISOString(), `start the request`);

// Call the endpoint described above
axios
  .get(`http://localhost:3333/api?token=${token}`)
  .then((resp) =&gt; {
    // Print the total length of requested data (an array of random numbers)
    console.info(new Date().toISOString(), `got ${resp.data.length} records`);
    process.exit(0);
  })
  .catch((e) =&gt; {
    console.info(e);
    process.exit(0);
  });
// We need to connect to the related Socket Server
const ioClient = io.connect('ws://localhost:3333');
// And wait for `progress-${token}` event
ioClient.on(`progress-${token}`, (progress) =&gt;
  console.info(new Date().toISOString(), `processed ${progress}%`)
);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_final_steps">The Final Steps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s time to try the solution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">git clone git@github.com:buchslava/nest-request-progress.git
cd nest-request-progress
npm i
npx nx run server:serve</code></pre>
</div>
</div>
<div class="paragraph">
<p>Open another terminal and run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">npx nx run client:serve</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_voilà">Voilà</h2>
<div class="sectionbody">
<div class="imageblock img">
<div class="content">
<img src="assets/articles/monitoring-the-progress-of-an-http-request-in-nestjs-via-websockets/img1.png" alt="img1">
</div>
</div>
</div>
</div>
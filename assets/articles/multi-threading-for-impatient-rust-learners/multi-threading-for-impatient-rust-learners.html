<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As a full-stack developer, I always try to gain new knowledge. I
heard about Rust Programming Language some years ago, but hands did not reach out to try real examples. I spent some time on Rust a couple of days ago, and I want to share some experiences with you.</p>
</div>
<div class="paragraph">
<p>First, I want to note that this article is suitable mainly for NodeJS/Javascript developers who didn&#8217;t hear about Rust before or for those who are trying the first steps.</p>
</div>
<div class="paragraph">
<p>Second, I&#8217;ll describe only one issue I tackled, and I don&#8217;t aim to provide you with the ultimate set of knowledge. Despite that, I hope my example will engage you regarding learning Rust.</p>
</div>
<div class="paragraph">
<p>I suppose, at this point, you ask me a question. As a Web developer, why should I learn Rust? I predicted this question. Honestly, this article is a logical continuation of <a href="https://valor-software.com/articles/node-rust-friendship-forever-the-napi-rs-way" target="_blank" rel="noopener">my previous one</a>.</p>
</div>
<div class="paragraph">
<p>It&#8217;s time to tell you a couple of words about Rust.</p>
</div>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Rust_(programming_language)"" target="_blank" rel="noopener">Wikipedia</a> tells us about Rust the following.</p>
</div>
<div class="paragraph">
<p><em>"Rust is a multi-paradigm, high-level, general-purpose programming language. Rust emphasizes performance, type safety, and concurrency. Rust enforces memory safety—that is, that all references point to valid memory—without requiring the use of a garbage collector or reference counting present in other memory-safe languages. To simultaneously enforce memory safety and prevent concurrent data races, Rust&#8217;s "borrow checker" tracks the object lifetime of all references in a program during compilation. Rust is popular for systems programming but also offers high-level features including some functional programming constructs. Software developer Graydon Hoare created Rust as a personal project while working at Mozilla Research in 2006. Mozilla officially sponsored the project in 2009. Since the first stable release in May 2015, Rust has been adopted by companies including Amazon, Discord, Dropbox, Facebook (Meta), Google (Alphabet), and Microsoft."</em></p>
</div>
<div class="paragraph">
<p>Don&#8217;t think about <a href="https://www.rust-lang.org/" target="_blank" rel="noopener">Rust</a> as a Javascript-similar one. This language is entirely different. Please, pay attention to the points below.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Rust is a compilable language.</p>
</li>
<li>
<p>Despite its general purpose, it mostly looks like a competitor in C++ (even C). If you are Golang-familiar folk, please, don&#8217;t compare Rust with Golang! They are different too.</p>
</li>
<li>
<p>One of the main features is safe Multi-Threading.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html" target="_blank" rel="noopener">References and Borrowing</a> topic could be a bit difficult for Javascript folk. Please, focus on it!</p>
</li>
<li>
<p>Please, read <a href="https://doc.rust-lang.org/stable/book/" target="_blank" rel="noopener">this resource</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>I want to focus on safe Multi-Threading in this article because understanding this feature is the number one way to understand this beautiful language. I also understand that the safe Multi-Threading topic is one of the trickiest in languages outside Rust. Java, Goalng, and C++ are good examples. Rust language has a large community, and there are many resources ( <a href="https://doc.rust-lang.org/stable/book" target="_blank" rel="noopener">this one</a>, for example) about it. But I was faced with a lack of practical examples and simple explanations. Despite that, I found one classic example that helps you to enter this topic as quickly as possible.</p>
</div>
<div class="sect2">
<h3 id="_meet_dining_philosophers">Meet Dining Philosophers!</h3>
<div class="paragraph">
<p><mark>Dining Philosophers Problem</mark> is a classic Multi-Threading task described <a href="https://www.hackertouch.com/dining-philosophers-problem-in-rust.html" target="_blank" rel="noopener">here</a>.</p>
</div>
<div class="paragraph">
<p><em>"Five silent philosophers sit at a round table with bowls of spaghetti. Forks are placed between each pair of adjacent philosophers. Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right forks. Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both forks so that the forks become available to others. A philosopher can take the fork on their right or the one on their left as they become available, but cannot start eating before getting both forks. Eating is not limited by the remaining amounts of spaghetti or stomach space; an infinite supply and an infinite demand are assumed. The problem is how to design a discipline of behavior (a concurrent algorithm) such that no philosopher will starve; i.e., each can forever continue to alternate between eating and thinking, assuming that no philosopher can know when others may want to eat or think."</em></p>
</div>
<div class="paragraph">
<p>Initially, Rust&#8217;s solution looked like the one below. You can find it <a href="https://github.com/buchslava/dining-philosophers-problem/tree/original-version" target="_blank" rel="noopener">here</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use std::sync::{Arc, Mutex};
use std::{thread, time};

struct Philosopher {
    name: String,
    left: usize,
    right: usize,
}

impl Philosopher {
    fn new(name: &amp;str, left: usize, right: usize) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
            left: left,
            right: right,
        }
    }

    fn eat(&amp;self, table: &amp;Table) {
        let _left = table.forks[self.left].lock().unwrap();
        let _right = table.forks[self.right].lock().unwrap();

        println!("{} is eating.", self.name);

        let delay = time::Duration::from_millis(1000);

        thread::sleep(delay);

        println!("{} is done eating.", self.name);
    }
}

struct Table {
    forks: Vec&lt;Mutex&lt;()&gt;&gt;,
}

fn main() {
    let table = Arc::new(Table {
        forks: vec![
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
        ],
    });


    let philosophers = vec![
        Philosopher::new("Donald", 0, 1),
        Philosopher::new("Larry", 1, 2),
        Philosopher::new("Mark", 2, 3),
        Philosopher::new("John", 3, 4),
        Philosopher::new("Bruce", 0, 4),
    ];

    let handles: Vec&lt;_&gt; = philosophers
        .into_iter()
        .map(|p| {
            let table = table.clone();

            thread::spawn(move || {
                p.eat(&amp;table);
            })
        })
        .collect();

    for h in handles {
        h.join().unwrap();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>I don&#8217;t want to dig into the code above a lot, and I guess you will enjoy doing it from your side. But I need to focus on some essential points.</p>
</div>
<div class="paragraph">
<p>It&#8217;s no secret that the main Multi-Threading task is about preventing data collisions. In our example, collision means neighbor philosophers simultaneously took the same fork because each philosopher has his thread and is eating and thinking simultaneously with others. <a href="https://fongyoong.github.io/easy_rust/Chapter_43.html" target="_blank" rel="noopener">Mutex</a> tackles it. Mutex means mutual exclusion, "only one at a time." That&#8217;s why forks association with the related mutexes is a great idea.</p>
</div>
<div class="paragraph">
<p>At this point, I&#8217;d like to interrupt my story and tell you one important note. Honestly, this example is more complicated than I&#8217;m explaining it. I just aim to excite new Rust folks. Sorry for telling you that, dear experts. Despite Mutex being a golden concurrency standard, it&#8217;s not a panacea. Some issues are possible even here. I&#8217;ll provide more helpful information about that in the article&#8217;s <strong>The Roadmap</strong> part. Please, read carefully about "Deadlock," "Livelock," and "Starvation."</p>
</div>
<div class="paragraph">
<p>The related code is the following.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">    let table = Arc::new(Table {
        forks: vec![
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
        ],
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>and</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">        let _left = table.forks[self.left].lock().unwrap();
        let _right = table.forks[self.right].lock().unwrap();</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_the_code_above_literally_means_the_following">The code above literally means the following.</h5>
<div class="paragraph">
<p>A philosopher takes a couple of forks and holds them.</p>
</div>
<div class="paragraph">
<p>What happens with his neighbors at this moment?
<strong><em>They want to take a fork. But the fork is already taken.</em></strong></p>
</div>
<div class="paragraph">
<p>What happens in this case with the neighbors?
<strong><em>They (means related threads) are waiting when the first philosopher releases the forks (unlocks his mutexes).</em></strong></p>
</div>
<div class="paragraph">
<p>Why are they waiting?
<strong><em>Because of mutexes!</em></strong></p>
</div>
<div class="paragraph">
<p>Look at the code below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">    fn eat(&amp;self, table: &amp;Table) {
        let _left = table.forks[self.left].lock().unwrap();
        let _right = table.forks[self.right].lock().unwrap();

        println!("{} is eating.", self.name);

        let delay = time::Duration::from_millis(1000);

        thread::sleep(delay);

        println!("{} is done eating.", self.name);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the philosopher leaves the forks?</p>
</div>
<div class="paragraph">
<p><em>He grabs the forks and waits for 1 second. The mutexes will be released after the <mark>eat</mark> function is completed.</em>
<em>Other lucky neighbors (right and left) grab the related forks. Pay attention to neighbors running in separate threads (i.e., simultaneously).</em></p>
</div>
<div class="paragraph">
<p>Also, let&#8217;s look at the following code directly related to multi-threading.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">    let handles: Vec&lt;_&gt; = philosophers
        .into_iter()
        .map(|p| {
            let table = table.clone();

            thread::spawn(move || {
                p.eat(&amp;table);
            })
        })
        .collect();

    for h in handles {
        h.join().unwrap();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s time to run the original example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">git clone git@github.com:buchslava/dining-philosophers-problem.git
cd dining-philosophers-problem
git checkout original-version
cargo build
./target/debug/dining-philosophers</code></pre>
</div>
</div>
<div class="imageblock img">
<div class="content">
<img src="assets/articles/multi-threading-for-impatient-rust-learners/img1.gif" alt="img1">
</div>
</div>
<div class="paragraph">
<p>I asked myself.
<em>Is it possible to collect all results during the program execution (I mean print messages) and provide them immediately after the whole logic has been completed?</em></p>
</div>
<div class="paragraph">
<p>I found this task challenging because I know from other technologies that cross-thread interaction is always painful. As a Javascript folk, I first thought about something like <mark>Promise.all</mark> technique.</p>
</div>
<div class="paragraph">
<p>Surprisingly, I found a similar technique in <a href="https://blog.yoshuawuyts.com/" target="_blank" rel="noopener">YOSHUA WUYTS blog</a>. I strongly recommend reading this resource.</p>
</div>
<div class="paragraph">
<p>Please, look at the <a href="https://blog.yoshuawuyts.com/futures-concurrency/" target="_blank" rel="noopener">following article</a>.</p>
</div>
<div class="paragraph">
<p>Moreover, I found the following table pleasant for Javascript folk.</p>
</div>
<table class="tableblock frame-all grid-all stretch turbo-table">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JavaScript</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rust</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Promise.allSettled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">future::join</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">does not short-circuit</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Promise.all</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">future::try_join</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">short-circuits when an input value is rejected</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Promise.race</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">future::select</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">short-circuits when an input value is settled</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Promise.any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">future::try_select</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">short-circuits when an input value is fulfilled</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>According to the information above, the new solution should look like the one below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use async_std::future;

let a = future::ready(Ok(1));
let b = future::ready(Ok(2));

let c = future::try_join(a, b);
assert_eq!(c.await?, (1, 2));</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an impatient learner, I looked at the futures approach and the origin example at the same time. I was slightly disappointed because I couldn&#8217;t reimplement the original version in a future-based way. Honestly, I don&#8217;t have enough time for that. In addition, according to digging results, the future&#8217;s concept is drastically different from threads. That&#8217;s why I&#8217;m not sure this idea is good. I postponed this activity.</p>
</div>
<div class="paragraph">
<p>I decided to choose another way. I researched more and found <a href="https://doc.rust-lang.org/stable/book/ch16-02-message-passing.html" target="_blank" rel="noopener">Using Message Passing to Transfer Data Between Threads</a>.</p>
</div>
<div class="paragraph">
<p>I think you would agree the way below is most friendly to the original Dinning Philosophers implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s time to move forward and modify our solution. I want to provide the complete source code and explain it step by step.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use std::sync::{Arc, Mutex};
use std::{thread, time};
use std::sync::mpsc::{Sender};
use std::sync::mpsc;

struct Philosopher {
    name: String,
    left: usize,
    right: usize,
}

impl Philosopher {
    fn new(name: &amp;str, left: usize, right: usize) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
            left: left,
            right: right,
        }
    }

    fn eat(&amp;self, table: &amp;Table, sender: &amp;Sender&lt;String&gt;) {
        let _left = table.forks[self.left].lock().unwrap();
        let _right = table.forks[self.right].lock().unwrap();

        // println!("{} is eating.", self.name);
        sender.send(format!("{} is eating.", self.name).to_string()).unwrap();

        let delay = time::Duration::from_millis(1000);

        thread::sleep(delay);

        // println!("{} is done eating.", self.name);
        sender.send(format!("{} is done eating.", self.name).to_string()).unwrap();
    }
}

struct Table {
    forks: Vec&lt;Mutex&lt;()&gt;&gt;,
}

fn main() {
    let (tx, rx) = mpsc::channel();
    let table = Arc::new(Table {
        forks: vec![
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
        ],
    });


    let philosophers = vec![
        Philosopher::new("Donald", 0, 1),
        Philosopher::new("Larry", 1, 2),
        Philosopher::new("Mark", 2, 3),
        Philosopher::new("John", 3, 4),
        Philosopher::new("Bruce", 0, 4),
    ];

    let handles: Vec&lt;_&gt; = philosophers
        .into_iter()
        .map(|p| {
            let table = table.clone();
            let sender = tx.clone();

            thread::spawn(move || {
                p.eat(&amp;table, &amp;sender);
            })
        })
        .collect();

    for h in handles {
        h.join().unwrap();
    }

    tx.send("Done".to_string()).unwrap();

    let mut result: String = String::from("");

    for received in rx {
        if received == "Done" {
            break;
        }
        result.push_str(&amp;received);
        result.push_str("\n");
    }
    println!("{}", result);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_add_related_packages">Add related packages</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use std::sync::mpsc::{Sender};
use std::sync::mpsc;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_initialize_the_channel">Initialize the channel</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">fn main() {
    let (tx, rx) = mpsc::channel();
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pass_the_sender_to_the_eat_function">Pass the sender to the <mark>eat</mark> function</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">            thread::spawn(move || {
                p.eat(&amp;table, &amp;sender);
            })</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_send_expected_information_instead_immediate_printing">Send expected information instead immediate printing</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">fn eat(&amp;self, table: &amp;Table, sender: &amp;Sender&lt;String&gt;) {
        let _left = table.forks[self.left].lock().unwrap();
        let _right = table.forks[self.right].lock().unwrap();

        // println!("{} is eating.", self.name);
        sender.send(format!("{} is eating.", self.name).to_string()).unwrap();

        let delay = time::Duration::from_millis(1000);

        thread::sleep(delay);

        // println!("{} is done eating.", self.name);
        sender.send(format!("{} is done eating.", self.name).to_string()).unwrap();
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gather_the_final_result">Gather the final result</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">    for h in handles {
        h.join().unwrap();
    }

    tx.send("Done".to_string()).unwrap();

    let mut result: String = String::from("");

    for received in rx {
        if received == "Done" {
            break;
        }
        result.push_str(&amp;received);
        result.push_str("\n");
    }
    println!("{}", result);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pay attention to the "Done" message. This is a criterion of the end of the process.</p>
</div>
<div class="paragraph">
<p>It&#8217;s time to run the final solution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">git checkout main
cargo build
./target/debug/dining-philosophers</code></pre>
</div>
</div>
<div class="imageblock img">
<div class="content">
<img src="assets/articles/multi-threading-for-impatient-rust-learners/img2.gif" alt="img2">
</div>
</div>
<div class="paragraph">
<p>Looks good!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_roadmap">The Roadmap.</h3>
<div class="paragraph">
<p>As promised, I will provide some crucial additions to this task.</p>
</div>
<div class="sect3">
<h4 id="_the_task_restrictions">The Task Restrictions.</h4>
<div class="paragraph">
<p>A deadlock can occur in this task when all philosophers hold exactly one single fork. This is currently being worked around in the article by ignoring <mark>the the philosophers sit at a round table</mark>: Since Donald and Bruce share the same left fork (0), one of them will never be able to hold one fork if the other holds any number of forks (due to constantly trying left first).
If we consider the round table part, Bruce’s left fork should be 4, and his right fork should be 0:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">Philosopher::new("Bruce", 4, 0),</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, this introduces a possible deadlock. It’s tough to replicate, but it’s easy to replicate once we implement the "an infinite supply and an infinite demand is assumed" part. As in infinite time, we will eventually hit a deadlock where all philosophers will be stuck thinking forever.</p>
</div>
<div class="paragraph">
<p>An easy way to reproduce it is to add a 5ms wait on every philosopher’s left fork pickup; it will deadlock.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use std::sync::{Arc, Mutex};
use std::{thread, time};

struct Philosopher {
    name: String,
    left: usize,
    right: usize,
}

impl Philosopher {
    fn new(name: &amp;str, left: usize, right: usize) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
            left: left,
            right: right,
        }
    }

    fn eat(&amp;self, table: &amp;Table) {
        println!("{} is picking up the left fork.", self.name);
        let _left = table.forks[self.left].lock().unwrap();

        // added 5ms duration
        thread::sleep(time::Duration::from_millis(5));

        println!("{} is picking up the right fork.", self.name);
        let _right = table.forks[self.right].lock().unwrap();

        println!("{} is eating.", self.name);

        let delay = time::Duration::from_millis(1000);

        thread::sleep(delay);

        println!("{} is done eating.", self.name);
    }
}

struct Table {
    forks: Vec&lt;Mutex&lt;()&gt;&gt;,
}

fn main() {
    let table = Arc::new(Table {
        forks: vec![
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
            Mutex::new(()),
        ],
    });


    let philosophers = vec![
        Philosopher::new("Donald", 0, 1),
        Philosopher::new("Larry", 1, 2),
        Philosopher::new("Mark", 2, 3),
        Philosopher::new("John", 3, 4),
        // changed from Philosopher::new("Bruce", 0, 4),
        Philosopher::new("Bruce", 4, 0),
    ];

    let handles: Vec&lt;_&gt; = philosophers
        .into_iter()
        .map(|p| {
            let table = table.clone();

            thread::spawn(move || {
                p.eat(&amp;table);
            })
        })
        .collect();

    for h in handles {
        h.join().unwrap();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can find a working (but really not working&#8230;&#8203;) example <a href="https://github.com/buchslava/dining-philosophers-problem/tree/deadlock" target="_blank" rel="noopener">here</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_useful_information_and_references">Useful Information and References</h4>
<div class="paragraph">
<p>As a concurrency folk, you should start thinking about <mark>Deadlock</mark>, <mark>Livelock</mark>, and <mark>Starvation</mark>. Please, read about it <a href="https://www.baeldung.com/cs/deadlock-livelock-starvation" target="_blank" rel="noopener">here</a>.</p>
</div>
<div class="paragraph">
<p>Tackling <mark>Deadlock</mark>, <mark>Livelock</mark>, and <mark>Starvation</mark> is not easy, and there is no silver bullet here. Despite you can dig into different existing solutions on the topic. <a href="https://github.com/shelbyd/cooptex" target="_blank" rel="noopener">This one</a>, for example.</p>
</div>
<div class="paragraph">
<p>Also, it would be best if you learned Atomic Calculations. To become the Ninja of Concurrency, start digging from <a href="https://marabos.nl/atomics/" target="_blank" rel="noopener">Rust Atomics and Locks Low-Level Concurrency in Practice</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nodejs">NodeJS</h3>
<div class="paragraph">
<p>Finally, I will satisfy your curiosity and give you a <a href="https://github.com/buchslava/dining-philosophers-problem/blob/main/nodejs/index.js" target="_blank" rel="noopener">NodeJS version</a> of the solution. It was taken from <a href="https://gist.github.com/Leko/753c3c53ab9a45f7dcbd1519dfca2cbd" target="_blank" rel="noopener">here</a> and corrected a bit&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>You could read and run it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">cd nodejs
node index</code></pre>
</div>
</div>
<div class="paragraph">
<p>I hope it will also widen your NodeJS horizons.</p>
</div>
</div>
<div class="sect2">
<h3 id="_happy_hacking">Happy hacking!</h3>
<div class="paragraph">
<p>PS: Thanks to <a href="https://dev.to/edusperoni" target="_blank" rel="noopener">Eduardo Speroni</a> for very useful comments and for helping during my work on the article.</p>
</div>
</div>
</div>
</div>
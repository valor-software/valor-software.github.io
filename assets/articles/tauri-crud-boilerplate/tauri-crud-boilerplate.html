<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hi, dear <a href="https://tauri.app" target="_blank" rel="noopener">Tauri</a>! Long time no see. I published my first post, <a href="https://valor-software.com/articles/developing-a-desktop-application-via-rust-and-nextjs-the-tauri-way" target="_blank" rel="noopener">Developing a Desktop Application via Rust and NextJS. The Tauri Way</a> almost a year ago. Since then, Tauri has become stronger. I&#8217;m happy about that! And now, I am very pleased to make a useful contribution to the Tauri community. As a full-stack developer, I frequently face situations where I need to start a DB-based UI project as fast as possible. It&#8217;s stressful if I need to start the project from 100% scratch. I prefer to keep some boilerplates on hand, which will save me time and nerves and will be the subject of this article.</p>
</div>
<div class="paragraph">
<p>I want to present you with my first version of the <a href="https://github.com/buchslava/tauri-crud-boilerplate" target="_blank" rel="noopener">Tauri CRUD Boilerplate</a>, which will help you bootstrap and prototype a new Tauri project from scratch. Let me focus on explanations in a What-Where-When style.</p>
</div>
<div class="paragraph">
<p>My <mark>Tauri CRUD Boilerplate</mark> is not a silver bullet; it&#8217;s just a set of valuable scratches that help you build and connect the DB and UI parts via Tauri. Also, the Tauri CRUD Boilerplate is useful primarily for fast prototyping because it contains React and Ant Design as UI players inside, and, of course, you can substitute them with another library or framework or even provide your custom solution instead. If we focus on the DB part, I use SQLite due to its simplicity and portability. In the future, you can change SQLite. As a roadmap, I&#8217;ll think about the second version of the bootstrap when DB will be substituted with the equivalent REST API plus authentication.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s get started.</p>
</div>
<div class="paragraph">
<p>There are a couple of <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/crud/data.rs" target="_blank" rel="noopener">tables</a>, <mark>person</mark> and <mark>todo</mark>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">CREATE TABLE IF NOT EXISTS person (
    id INTEGER PRIMARY KEY NOT NULL,
    name VARCHAR(250) NOT NULL
);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">CREATE TABLE IF NOT EXISTS todo (
    id INTEGER PRIMARY KEY NOT NULL,
    date VARCHAR(20) NOT NULL,
    notes TEXT,
    person_id INTEGER NOT NULL,
    completed INTEGER NOT NULL,
    FOREIGN KEY(person_id) REFERENCES person(id)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As we can see, each person can contain a set of todos. <mark>person_id</mark> is a foreign key here.</p>
</div>
<div class="paragraph">
<p>I implemented the following functionality.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Data management (see <mark>Data</mark> tab below). The main aim is to create an empty SQLite DB (according to the definitions above) and fill it with the test data.</p>
</li>
<li>
<p>The Persons tab contains a table that shows a set of persons and provides functionality for adding, editing, and deleting them.</p>
</li>
<li>
<p>The Todos tab contains two related widgets: Persons as a read-only list and a table that shows a set of person-related todos. It provides functionality for adding, editing, and deleting them.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_data">Data</h3>
<div class="imageblock img">
<div class="content">
<img src="assets/articles/tauri-crud-boilerplate/img1.png" alt="img1">
</div>
</div>
<div class="paragraph">
<p>Let me highlight some essential points in the <mark>Data</mark> tab code.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can find <mark>Create DB</mark>-related DB code <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/crud/data.rs" target="_blank" rel="noopener">here(#L6-L38)</a> and UI code <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Data.tsx" target="_blank" rel="noopener">here(#L25)</a>.</p>
</li>
<li>
<p>You can find <mark>Fill DB</mark>-related DB code <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Data.tsx" target="_blank" rel="noopener">here(#L26)</a> and UI code <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Data.tsx" target="_blank" rel="noopener">here(#L26)</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s important to have test data and the ability to recreate it when needed (via <mark>Create DB</mark>). If you want to remove the DB, you can just delete a related file.</p>
</div>
</div>
<div class="sect2">
<h3 id="_db_connect">DB connect</h3>
<div class="paragraph">
<p>It&#8217;s time to know how the connection with the DB works. First, we need to get the <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/util/db.rs" target="_blank" rel="noopener">SQLite DB path(#L7)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">fn get_database_path() -&gt; io::Result&lt;PathBuf&gt; {
    let mut exe = env::current_exe()?;
    exe.set_file_name("./db");
    #[cfg(dev)]
    exe.set_file_name("../../../db");
    Ok(exe)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In production mode, we use the current folder to keep the DB, and the DB will be kept in the same folder as the executable file. But in the case of the debug mode, I prefer to keep the database file at the root of the project. Because the executable file in debug mode is placed in <mark>[project folder]/src-tauri/target/debug</mark>, we conditionally use the <mark>../../../</mark> path that&#8217;s equal to the project folder in debug mode. Fortunately, the <a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html" target="_blank" rel="noopener">cfg</a> attribute helps us to do that. BTW, you can change this logic if needed.</p>
</div>
<div class="paragraph">
<p>After we have a DB part, we need to get a <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/util/db.rs" target="_blank" rel="noopener">path as a string</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">pub fn get_database() -&gt; String {
    let db_url = match get_database_path() {
        Ok(path) =&gt; path.into_os_string().into_string().unwrap(),
        Err(e) =&gt; e.to_string(),
    };
    return db_url;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the util function above in other functions the following way. For example, when we need to <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/crud/person.rs" target="_blank" rel="noopener">insert a new record into the person table(#L14)</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">#[tauri::command]
pub async fn person_insert(name: &amp;str) -&gt; Result&lt;i64, String&gt; {
    // get DB url as a string
    let db_url = util::db::get_database();
    // Connect with the DB; get connection from the pool
    let db = SqlitePool::connect(&amp;db_url).await.unwrap();
    // Do all needed DB stuff
    let query_result = sqlx
        ::query("INSERT INTO person (name) VALUES (?)")
        .bind(name)
        .execute(&amp;db).await;
    if query_result.is_err() {
        db.close().await;
        return Err(format!("{:?}", query_result.err()));
    }

    let id = query_result.unwrap().last_insert_rowid();
    // Close the connection
    db.close().await;
    Ok(id)
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_persons">Persons</h3>
<div class="paragraph">
<p>It&#8217;s time to understand how our first CRUD works on the example of <mark>Persons</mark>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s dig into the UI part. You can read full text of the component <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Person.tsx" target="_blank" rel="noopener">here</a>.</p>
</div>
<div class="paragraph">
<p>Also, let&#8217;s dig into the <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Person.tsx" target="_blank" rel="noopener">data loading(#L41-L58)</a>. Please, read comment in the following code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">const load = async () =&gt; {
    try {
      // get the data
      const result = await apiCall("person_select");
      // make it as a JSON
      const items = JSON.parse(JSON.parse(result as unknown as string));
      // set the related React state variable
      setData(
        items.map((item: any) =&gt; ({
          key: item.id,
          ...item,
        }))
      );
    } catch (e) {
      console.error(e);
      errorMessage.open({
        type: "error",
        content: "Can't load the person list",
      });
    }
  };</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s focus on <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/util.ts" target="_blank" rel="noopener">apiCall</a> function. This function is important because it&#8217;s a link between React and Rust parts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">import { InvokeArgs, invoke } from "@tauri-apps/api/tauri";

export const apiCall = async &lt;T&gt;(
  name: string,
  parameters?: InvokeArgs
): Promise&lt;T&gt; =&gt;
  new Promise((resolve, reject) =&gt;
    invoke(name, parameters)
      .then(resolve as (value: unknown) =&gt; PromiseLike&lt;T&gt;)
      .catch(reject)
  );</code></pre>
</div>
</div>
<div class="paragraph">
<p>We import <mark>invoke</mark> function from <mark>@tauri-apps/api/tauri</mark> and just call the following functionality in Rust part. In this example we are talking about <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/crud/person.rs" target="_blank" rel="noopener">person_select(#L61-L76)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">#[tauri::command]
pub async fn person_select() -&gt; Result&lt;String, String&gt; {
    let db_url = util::db::get_database();
    let db = SqlitePool::connect(&amp;db_url).await.unwrap();
    let query_result = sqlx
        ::query_as::&lt;_, Person&gt;("SELECT id, name FROM person ORDER BY id DESC")
        .fetch_all(&amp;db).await;
    if query_result.is_err() {
        db.close().await;
        return Err(format!("{:?}", query_result.err()));
    }
    let results = query_result.unwrap();
    let encoded_message = serde_json::to_string(&amp;results).unwrap();
    db.close().await;
    Ok(format!("{:?}", encoded_message))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, I&#8217;d like to focus your attention on the <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/crud/person.rs" target="_blank" rel="noopener">following data structure(#L7-L11)</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">#[derive(Serialize, Clone, FromRow, Debug)]
pub struct Person {
    id: i64,
    name: String,
}</code></pre>
</div>
</div>
<div class="imageblock img">
<div class="content">
<img src="assets/articles/tauri-crud-boilerplate/img2.png" alt="img2">
</div>
</div>
<div class="paragraph">
<p>After that, I intend to be brief because I don&#8217;t want to waste your time. That&#8217;s why I am providing you with some significant points regarding the code.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at <mark>Insert</mark> and <mark>Edit</mark>&#8230;&#8203;</p>
</div>
<div class="imageblock img">
<div class="content">
<img src="assets/articles/tauri-crud-boilerplate/img3.png" alt="img3">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Press <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Person.tsx" target="_blank" rel="noopener">New Person(#L140)</a> button or <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Person.tsx" target="_blank" rel="noopener">Edit(#L80)</a> button on each row of data.</p>
</li>
<li>
<p>Both of <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Person.tsx" target="_blank" rel="noopener">addNewRow(#L130)</a> and <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Person.tsx" target="_blank" rel="noopener">doEdit(#L36-L39)</a> works with the modal window <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Person.tsx" target="_blank" rel="noopener">here(#L36-L39)</a> that use <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/PersonEdit.tsx" target="_blank" rel="noopener">PersonEdit</a> component.</p>
</li>
<li>
<p>The <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Person.tsx" target="_blank" rel="noopener">following logic(#L103-L125)</a> works when the form from the component above has been submitted. Its main goal is to make all expected changes (call Rust code), hide the modal window, or show the error if it is not OK.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_todos">Todos</h3>
<div class="paragraph">
<p><mark>Todos</mark> functionality is a bit more complicated than <mark>Persons</mark> because it contains <mark>Persons</mark> and is represented by <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/TodoContainer.tsx" target="_blank" rel="noopener">TodoContainer</a> component that you see below. Let&#8217;s focus on how TodoContainer works.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It based on a <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/TodoContainer.tsx" target="_blank" rel="noopener">Antd&#8217;s Tab(#L39)</a> component.</p>
</li>
<li>
<p>Tab&#8217;s <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/TodoContainer.tsx" target="_blank" rel="noopener">items are persons(#L14)</a>.</p>
</li>
<li>
<p>Each Tab-person has its own <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/TodoContainer.tsx" target="_blank" rel="noopener">Todo(#L20)</a> table that also contains adding and editing functionalities.</p>
</li>
</ol>
</div>
<div class="imageblock img">
<div class="content">
<img src="assets/articles/tauri-crud-boilerplate/img4.png" alt="img4">
</div>
</div>
<div class="paragraph">
<p>Focusing on the <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Todo.tsx" target="_blank" rel="noopener">Todo</a> and <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/TodoEdit.tsx" target="_blank" rel="noopener">TodoEdit</a> components doesn&#8217;t matter because their logic is similar to that of Person and PersonEdit.</p>
</div>
<div class="imageblock img">
<div class="content">
<img src="assets/articles/tauri-crud-boilerplate/img5.png" alt="img5">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_use">How to use</h3>
<div class="paragraph">
<p>I want to stop discussing the code and focus on some practical aspects. Let&#8217;s run the app in dev mode.</p>
</div>
<div class="paragraph">
<p>Traditionally,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">npm ci</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run in dev mode</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">npm run tauri dev</code></pre>
</div>
</div>
<div class="imageblock img">
<div class="content">
<img src="assets/articles/tauri-crud-boilerplate/img6.gif" alt="img6">
</div>
</div>
<div class="imageblock img">
<div class="content">
<img src="assets/articles/tauri-crud-boilerplate/img7.gif" alt="img7">
</div>
</div>
<div class="paragraph">
<p>In production mode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">npm run tauri build</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can found:</p>
</div>
<div class="paragraph">
<p>An installer-based (dmg) app in <mark>[project root]/src-tauri/target/release/bundle/dmg</mark> if you want to run the installer
Or just the app in <mark>[project root]/src-tauri/target/release/bundle/macos</mark> if you want to run the app directly</p>
</div>
</div>
<div class="sect2">
<h3 id="_components_refreshing">Components refreshing</h3>
<div class="paragraph">
<p>The app&#8217;s most tricky part concerns data synchronization. Imagine we just added a new person to the <mark>Persons</mark> tab and moved them to the <mark>Todo</mark> tab. The person list on the left side should be refreshed, shouldn&#8217;t it? Let me share some thoughts about data synchronization.</p>
</div>
<div class="paragraph">
<p>I provided <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/GlobalContext.tsx" target="_blank" rel="noopener">a context</a> that contains the following data.</p>
</div>
<div class="paragraph">
<p>*https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/GlobalContext.tsx[refreshDescriptor(#L9), window=_blank] that contains a couple of fields <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/GlobalContext.tsx" target="_blank" rel="noopener">person(#L4)</a> and <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/GlobalContext.tsx" target="_blank" rel="noopener">todo(#L5)</a>.
* A set of methods for the state refreshing: <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/GlobalContext.tsx" target="_blank" rel="noopener">refreshPerson(#L10)</a> and <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/GlobalContext.tsx" target="_blank" rel="noopener">refreshTodo(#L11)</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">import React, { createContext, useContext, useState } from "react";

export interface DataRefreshDescriptor {
  person: Date;
  todo: Date;
}

type GlobalContextProps = {
  refreshDescriptor: DataRefreshDescriptor;
  refreshPerson: () =&gt; void;
  refreshTodo: () =&gt; void;
};

const GlobalContext = createContext({} as GlobalContextProps);

export type TargetKey = React.MouseEvent | React.KeyboardEvent | string;

export const GlobalProvider = ({ children }: { children: React.ReactNode }) =&gt; {
  const now = new Date();
  const [refreshDescriptor, setRefreshDescriptor] =
    useState&lt;DataRefreshDescriptor&gt;({
      person: now,
      todo: now,
    });

  const refreshPerson = () =&gt; {
    setRefreshDescriptor({ ...refreshDescriptor, person: new Date() });
  };

  const refreshTodo = () =&gt; {
    setRefreshDescriptor({ ...refreshDescriptor, todo: new Date() });
  };

  return (
    &lt;GlobalContext.Provider
      value={{
        refreshDescriptor,
        refreshPerson,
        refreshTodo,
      }}
    &gt;
      {children}
    &lt;/GlobalContext.Provider&gt;
  );
};

export const useGlobalContext = () =&gt; useContext(GlobalContext);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following fragment of code illustrates us how to use the <mark>refreshDescriptor</mark>. Please, read comments there.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">// let's skip imports
export default function TodoContainer() {
  // get the refreshDescriptor
  const { refreshDescriptor } = useGlobalContext();
  const [errorMessage, errorMessageHolder] = message.useMessage();
  const [tabs, setTabs] = useState&lt;TabsProps["items"]&gt;([]);

  const loadPersons = async () =&gt; {
    // let's skip the details
  };

  useEffect(() =&gt; {
    // if refreshDescriptor.person has been changed, we need to reload the person list
    loadPersons();
  }, [refreshDescriptor.person]);

  return (
    &lt;&gt;
      {errorMessageHolder}
      &lt;Tabs tabPosition={"left"} items={tabs} /&gt;
    &lt;/&gt;
  );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please, look at another example of refreshing. You can find the full version <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Person.tsx" target="_blank" rel="noopener">here</a>. Please, read comments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">// imports ...

export default function Person() {
  const { refreshDescriptor, refreshPerson } = useGlobalContext();
  // skip...

  const doDelete = async (id: number) =&gt; {
    try {
      await apiCall("person_delete", { id });
      // change the 'person' field of the descriptor if a new person was deleted
      refreshPerson();
    } catch (e) {
      // skip...
    }
  };

  // skip...

  const load = async () =&gt; {
    // skip...
  };

  useEffect(() =&gt; {
    load();
    const columns: ColumnsType&lt;DataType&gt; = [
      /// skip...
    ];
    setColumns(columns);
  }, [refreshDescriptor.person]);

  const doEditOk = () =&gt; {
    editFormRef.current.submit();
  };

  const handleEditOk = async (formData: DataType) =&gt; {
    try {
      if (currentRecord?.id) {
        await apiCall("person_update", {
          name: formData.name,
          id: currentRecord.id,
        });
      } else {
        await apiCall("person_insert", {
          name: formData.name,
        });
      }
      setEditVisible(false);
      // change the 'person' field of the descriptor if a new person was added or changed
      refreshPerson();
    } catch (e) {
      setEditVisible(false);
      // skip...
    }
  };

  // skip...

  return !columns ? (
    &lt;&gt;&lt;/&gt;
  ) : (
    &lt;div&gt;
      {errorMessageHolder}
      &lt;Button onClick={addNewRow} style={{ margin: 10 }}&gt;
        New Person
      &lt;/Button&gt;
      &lt;Table
        columns={columns}
        dataSource={data}
        pagination={false}
        scroll={{ y: "calc(100vh - 200px)" }}
      /&gt;
      &lt;Modal
        title="Person"
        open={editVisible}
        onOk={doEditOk}
        onCancel={handleEditCancel}
      &gt;
        &lt;PersonEdit
          ref={editFormRef}
          currentRecord={currentRecord}
          handleEditOk={handleEditOk}
        &gt;&lt;/PersonEdit&gt;
      &lt;/Modal&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We call <mark>refreshPerson</mark> if we expect another or the current widget refreshing. If you add some new functionality in the future, you need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>add new fields to <mark>refreshDescriptor</mark></p>
</li>
<li>
<p>provide the related functions and add them to the context</p>
</li>
<li>
<p>use them the way described above</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_the_app_component">The App component</h3>
<div class="paragraph">
<p>I suppose it&#8217;s the simplest part of the solution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-code" data-lang="code">import { Tabs, TabsProps } from "antd";
import "./App.css";
import Person from "./Person";
import TodoContainer from "./TodoContainer";
import Data from "./Data";
import { useGlobalContext } from "./GlobalContext";

const tabs: TabsProps["items"] = [
  {
    key: "persons",
    label: "Persons",
    children: &lt;Person /&gt;,
  },
  {
    key: "todo",
    label: "Todo",
    children: &lt;TodoContainer /&gt;,
  },
  {
    key: "data",
    label: "Data",
    children: &lt;Data /&gt;,
  },
];

function App() {
  const { refreshPerson, refreshTodo } = useGlobalContext();

  return (
    &lt;Tabs
      items={tabs}
      onTabClick={(key: string) =&gt; {
        if (key === "persons") {
          refreshPerson();
        }
        if (key === "todo") {
          refreshTodo();
        }
      }}
    /&gt;
  );
}

export default App;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please pay attention to the <mark>onTabClick</mark> handler. We change the related fields of <mark>refreshDescriptor</mark> every time we open a related tab.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_recommendations">The recommendations</h3>
<div class="paragraph">
<p>This part is essential because all that I just told you should be continued with your, my dear reader, part. I aim to summarize and guide you regarding your future steps with the boilerplate. Of course, all that I intend to share with you is not dogma; it&#8217;s just my subjective opinion that I hope will help you.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>I recommend starting with the Rust part.</p>
</li>
<li>
<p>You could create a separate rs-file. This is a good <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/crud/person.rs" target="_blank" rel="noopener">example</a>. Also, don&#8217;t forget to add it to <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/crud/mod.rs" target="_blank" rel="noopener">mod.rs</a></p>
</li>
<li>
<p>After you need to make the following changes in <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/main.rs" target="_blank" rel="noopener">main.rs</a>: <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/main.rs" target="_blank" rel="noopener">use the module(#L6)</a> and <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src-tauri/src/main.rs" target="_blank" rel="noopener">tell Tauri about the new functionality(#L16-L19)</a>. That&#8217;s it regarding Rust-part. It&#8217;s time to code in React.</p>
</li>
<li>
<p>Create a table-based component like the <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/Person.tsx" target="_blank" rel="noopener">following</a></p>
</li>
<li>
<p>Create a form-based component like the <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/PersonEdit.tsx" target="_blank" rel="noopener">following</a></p>
</li>
<li>
<p>Use the table-based component in the <a href="https://github.com/buchslava/tauri-crud-boilerplate/blob/devto-article/src/App.tsx" target="_blank" rel="noopener">following way(#L12)</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>PS: It&#8217;s important to note that the solution above is just one of my first attempts at the topic; therefore, do not judge strictly. Also, I&#8217;d like to know how this solution works under Windows. Anyway, happy hacking, guys ;)</p>
</div>
</div>
</div>
</div>